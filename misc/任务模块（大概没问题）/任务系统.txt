需求分析：
task模块用于发布任务到memory中，任何单位可以通过task发布任务或接受任务。
任务的解决逻辑应该由接受者实现。

任务应以以下模式存储于内存中：
memory.task = Dict{hash:主任务 }

主任务=Dict{
	任务类型：String
	任务接受者的可接受任务类型列表为硬编码，任务接受者通过任务列表里的任务类型查找可用的任务。

	发布者：ObjectId
	用于给接受者查找相关数据

	范围：List[roomName]
	控制接受者的范围，空为全局。
	
	子任务列表：Dict{hash:子任务}

	存量：int
	该任务的存量，如剩余需求资源数，剩余生产数等。
	
	任务目标：Dict{}
	包含任务的一系列要求。
	如运输任务可有{
		目标对象：
		物品类型：
	}
	生产任务有{
		待生产的role：
	}
}


子任务由接受者申请，接受者向任务中心发送编号和存量来接受该种任务，任务中心创建一个子任务，并返回一个index交给接受者用于更新。
任务中心偶尔查看子任务列表查看任务是否完成

子任务应以以下模式存储于内存中。
子任务=Dict{
	index：int // 本来想用id的，怕关键字占用
	用于由子任务列表查找。
	
	接受者：ObjectId
	给调试人员好看的，应该可以删掉这条（代码里已经删了）。
	
	activeTime：int
	由接受者更新。接受者由于各种原因无法更新此项时(Game.time-activeTime>20)，视为任务失败。
	
	done：int
	用于通信，告诉接受者是否放弃该任务，告诉任务中心是否完成任务。
	0=进行中；1=完成任务；2=由接受者更新为此状态，任务失败；3=由发布者或任务系统为更新此状态，请接受者放弃。
	
	存量：int
	该任务失败时应返还的存量。
}

食用说明：
文档我就不写了，自己看方法就行。
任务model就类似task.spawnCreep那样写，写完后在mainSys的taskList里注册一下即可。
为了解耦，接受者查找任务通过model里的方法找，接受任务通过taskTools.subTaskIssue生成任务。
解决任务的逻辑写在接受者里，任务活跃时通过taskTools.subTaskRefresh更新。
PS：接受者可以直接调函数完成一个子任务，不用通过通信让主模块删任务。

版本说明：
version=1.0（最初版）
有关于taskKind的指针用于查找优化。
如果想加堆优化可以自己加在detail里。
下一版加房间相关的指针。
